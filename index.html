<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Colorful LifeGame</title>
  <style>
    :root {
      --bg: #0b0f18;
      --panel: rgba(20, 26, 38, 0.78);
      --line: rgba(255,255,255,0.12);
      --txt: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --btn: rgba(255,255,255,0.10);
      --btn2: rgba(255,255,255,0.16);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--txt); font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif; }
    #wrap { height: 100%; display: grid; grid-template-rows: auto 1fr; }
    header {
      padding: 10px 10px calc(10px + env(safe-area-inset-top));
      position: sticky; top: 0; z-index: 10;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,15,24,0.92), rgba(11,15,24,0.55));
      border-bottom: 1px solid var(--line);
    }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .row + .row { margin-top: 8px; }
    button, select, input[type="range"] {
      border: 1px solid var(--line);
      background: var(--btn);
      color: var(--txt);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
      line-height: 1;
    }
    button:active { background: var(--btn2); }
    button.primary { background: rgba(90, 180, 255, 0.18); }
    .pill {
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 12px;
      display: inline-flex; gap: 8px; align-items: center;
    }
    .kv { display: inline-flex; gap: 8px; align-items: center; }
    .kv label { font-size: 12px; color: var(--muted); }
    .kv input[type="range"] { padding: 0; height: 36px; width: 160px; }
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none; /* iOSでドラッグ描画を安定させる */
    }
    footerHint {
      display: block;
      padding: 10px 12px;
      color: rgba(255,255,255,0.62);
      font-size: 12px;
    }
  </style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="row">
      <button id="play" class="primary">Play</button>
      <button id="step">Step</button>
      <button id="random">Random</button>
      <button id="clear">Clear</button>

      <span class="pill" id="stats">Gen: 0 / Alive: 0</span>

      <span class="kv">
        <label for="cellSize">Cell</label>
        <input id="cellSize" type="range" min="4" max="24" value="10">
      </span>

      <span class="kv">
        <label for="speed">Speed</label>
        <input id="speed" type="range" min="1" max="60" value="20">
      </span>

      <span class="kv">
        <label for="colorMode">Color</label>
        <select id="colorMode">
          <option value="age">Age</option>
          <option value="neon">Neon</option>
          <option value="rainbow">Rainbow</option>
        </select>
      </span>

      <span class="kv">
        <label for="wrapEdges">Wrap</label>
        <select id="wrapEdges">
          <option value="on">ON</option>
          <option value="off">OFF</option>
        </select>
      </span>
    </div>
    <footerHint>タップ/ドラッグで描画。2本指はスクロール扱いになるので、基本は1本指で描画してください。</footerHint>
  </header>

  <canvas id="canvas"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { alpha: false });

  const playBtn = document.getElementById("play");
  const stepBtn = document.getElementById("step");
  const randomBtn = document.getElementById("random");
  const clearBtn = document.getElementById("clear");
  const cellSizeEl = document.getElementById("cellSize");
  const speedEl = document.getElementById("speed");
  const statsEl = document.getElementById("stats");
  const colorModeEl = document.getElementById("colorMode");
  const wrapEdgesEl = document.getElementById("wrapEdges");

  // 状態
  let cellSize = +cellSizeEl.value;
  let w = 0, h = 0, cols = 0, rows = 0;
  let gen = 0;
  let running = false;

  // 0/1の生死と、色用の「年齢」を持つ（年齢は生きている間だけ増える）
  let alive = null;     // Uint8Array
  let alive2 = null;    // Uint8Array
  let age = null;       // Uint16Array
  let age2 = null;      // Uint16Array

  // 描画向け
  let dpr = 1;
  let lastT = 0;
  let acc = 0;

  function resize() {
    dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    w = Math.floor(rect.width);
    h = Math.floor(rect.height);
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    cols = Math.max(10, Math.floor(w / cellSize));
    rows = Math.max(10, Math.floor(h / cellSize));

    alive = new Uint8Array(cols * rows);
    alive2 = new Uint8Array(cols * rows);
    age = new Uint16Array(cols * rows);
    age2 = new Uint16Array(cols * rows);
    gen = 0;

    // 初期は少しだけランダムにして見栄えを出す
    seedRandom(0.12);
    draw(true);
  }

  function idx(x, y) { return y * cols + x; }

  function seedRandom(density = 0.18) {
    for (let i = 0; i < alive.length; i++) {
      const v = Math.random() < density ? 1 : 0;
      alive[i] = v;
      age[i] = v ? (1 + (Math.random() * 6 | 0)) : 0;
    }
    gen = 0;
  }

  function clearAll() {
    alive.fill(0);
    age.fill(0);
    gen = 0;
  }

  function countNeighbors(x, y, wrap) {
    let n = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        let xx = x + dx, yy = y + dy;

        if (wrap) {
          if (xx < 0) xx += cols; else if (xx >= cols) xx -= cols;
          if (yy < 0) yy += rows; else if (yy >= rows) yy -= rows;
        } else {
          if (xx < 0 || xx >= cols || yy < 0 || yy >= rows) continue;
        }
        n += alive[idx(xx, yy)];
      }
    }
    return n;
  }

  function step() {
    const wrap = (wrapEdgesEl.value === "on");
    let aliveCount = 0;

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const i = idx(x, y);
        const a = alive[i];
        const n = countNeighbors(x, y, wrap);

        // ルール（ライフゲーム）
        // 生存: 2 or 3、誕生: 3
        let next = 0;
        if (a) next = (n === 2 || n === 3) ? 1 : 0;
        else next = (n === 3) ? 1 : 0;

        alive2[i] = next;

        if (next) {
          aliveCount++;
          // 年齢：生存継続なら増加、誕生なら1
          age2[i] = a ? Math.min(65535, age[i] + 1) : 1;
        } else {
          age2[i] = 0;
        }
      }
    }

    // swap
    [alive, alive2] = [alive2, alive];
    [age, age2] = [age2, age];

    gen++;
    return aliveCount;
  }

  function colorFor(x, y, a, mode) {
    // HSLで派手に。iOSでも軽い。
    // H: 色相(0-360), S: 彩度, L: 明るさ
    // （HSL＝色を「色合い/鮮やかさ/明るさ」で指定する方式）
    if (!a) return null;

    if (mode === "age") {
      // 年齢で色相が回る＋明るさで“成長”を出す
      const hue = (a * 8) % 360;
      const light = Math.min(70, 28 + a * 0.8);
      return `hsl(${hue} 95% ${light}%)`;
    }

    if (mode === "neon") {
      // ネオン寄り：座標も混ぜて揺らす
      const hue = (a * 10 + x * 2 + y * 1) % 360;
      const light = 55 + Math.min(15, a * 0.15);
      return `hsl(${hue} 100% ${light}%)`;
    }

    // rainbow
    {
      // 虹グラデ：座標で色相、年齢で明るさ
      const hue = (x * 6 + y * 3) % 360;
      const light = Math.min(70, 35 + a * 0.9);
      return `hsl(${hue} 95% ${light}%)`;
    }
  }

  function draw(forceFull = false) {
    // 背景を少しだけ残すと軌跡が出て鮮やかに見える
    // running中は薄くフェード、停止中は完全クリア
    if (running && !forceFull) {
      ctx.fillStyle = "rgba(11, 15, 24, 0.18)";
      ctx.fillRect(0, 0, w, h);
    } else {
      ctx.fillStyle = "#0b0f18";
      ctx.fillRect(0, 0, w, h);
    }

    const mode = colorModeEl.value;
    let aliveCount = 0;

    for (let y = 0; y < rows; y++) {
      const py = y * cellSize;
      for (let x = 0; x < cols; x++) {
        const i = idx(x, y);
        if (!alive[i]) continue;
        aliveCount++;

        const a = age[i];
        ctx.fillStyle = colorFor(x, y, a, mode);

        // セルに少し“隙間”を作ると見た目が締まる
        const pad = Math.max(1, Math.floor(cellSize * 0.08));
        ctx.fillRect(x * cellSize + pad, py + pad, cellSize - pad * 2, cellSize - pad * 2);
      }
    }

    statsEl.textContent = `Gen: ${gen} / Alive: ${aliveCount}`;
  }

  function setRunning(on) {
    running = on;
    playBtn.textContent = running ? "Pause" : "Play";
    if (running) requestAnimationFrame(loop);
  }

  function loop(t) {
    if (!running) return;
    if (!lastT) lastT = t;
    const dt = (t - lastT) / 1000;
    lastT = t;
    acc += dt;

    const hz = +speedEl.value;          // 1..60
    const stepSec = 1 / hz;

    // 追いつくまで複数ステップ（重い場合は上限をかける）
    let n = 0;
    while (acc >= stepSec && n < 6) {
      step();
      acc -= stepSec;
      n++;
    }

    draw(false);
    requestAnimationFrame(loop);
  }

  // 入力：タップ/ドラッグで描画
  let drawing = false;
  let drawValue = 1; // 1=生, 0=死

  function posToCell(clientX, clientY) {
    const r = canvas.getBoundingClientRect();
    const x = Math.floor((clientX - r.left) / cellSize);
    const y = Math.floor((clientY - r.top) / cellSize);
    return { x, y };
  }

  function paintAt(clientX, clientY) {
    const { x, y } = posToCell(clientX, clientY);
    if (x < 0 || y < 0 || x >= cols || y >= rows) return;
    const i = idx(x, y);
    alive[i] = drawValue;
    age[i] = drawValue ? Math.max(1, age[i]) : 0;
  }

  canvas.addEventListener("pointerdown", (e) => {
    // 2本指は操作が競合しやすいので無視（誤動作対策）
    if (e.pointerType === "touch" && e.isPrimary === false) return;

    drawing = true;
    canvas.setPointerCapture(e.pointerId);

    // そのセルが生なら消す、死なら生やす（直感操作）
    const { x, y } = posToCell(e.clientX, e.clientY);
    if (x >= 0 && y >= 0 && x < cols && y < rows) {
      const i = idx(x, y);
      drawValue = alive[i] ? 0 : 1;
      alive[i] = drawValue;
      age[i] = drawValue ? 1 : 0;
    }
    draw(true);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!drawing) return;
    paintAt(e.clientX, e.clientY);
    draw(true);
  });

  canvas.addEventListener("pointerup", () => { drawing = false; });
  canvas.addEventListener("pointercancel", () => { drawing = false; });

  // UI
  playBtn.addEventListener("click", () => setRunning(!running));
  stepBtn.addEventListener("click", () => { step(); draw(true); });
  randomBtn.addEventListener("click", () => { seedRandom(0.18); draw(true); });
  clearBtn.addEventListener("click", () => { clearAll(); draw(true); });

  cellSizeEl.addEventListener("input", () => {
    cellSize = +cellSizeEl.value;
    resize();
  });

  speedEl.addEventListener("input", () => {
    acc = 0; // 速度変更時の“詰まり”をリセット
  });

  colorModeEl.addEventListener("change", () => draw(true));
  wrapEdgesEl.addEventListener("change", () => draw(true));

  window.addEventListener("resize", resize);
  resize();
})();
</script>
</body>
</html>
