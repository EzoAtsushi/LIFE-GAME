<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Colorful LifeGame++</title>
  <meta name="theme-color" content="#f7f7f7" />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <style>
    :root{
      /* 白基調（モノクロUI） */
      --bg:#f7f7f7;
      --panel: rgba(255,255,255,.92);
      --line: rgba(0,0,0,.12);
      --txt: rgba(0,0,0,.88);
      --muted: rgba(0,0,0,.55);
      --btn: rgba(0,0,0,.04);
      --btn2: rgba(0,0,0,.08);
      --shadow: 0 8px 24px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);
      font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif}
    #wrap{height:100%;display:grid;grid-template-rows:auto 1fr}

    header{
      padding:10px 10px calc(10px + env(safe-area-inset-top));
      position:sticky;top:0;z-index:10;
      backdrop-filter: blur(10px);
      background:var(--panel);
      border-bottom:1px solid var(--line);
    }
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .row + .row{margin-top:8px}

    button,select,input[type="range"]{
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--txt);
      border-radius:10px;
      padding:9px 12px;
      font-size:14px;
      line-height:1.25;
      height:40px;
      box-shadow: 0 1px 0 rgba(255,255,255,.9) inset;
    }
    button:active{background:var(--btn2)}
    button.primary{background:rgba(0,0,0,.06)}

    input[type="range"]{padding:0;width:160px}

    /* プルダウンの選択肢が見えない対策 */
    select{ color: var(--txt); }
    option, optgroup{ color:#111; background:#fff; }

    .pill{
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background:rgba(0,0,0,.03);
      color:var(--muted);
      font-size:12px;line-height:1.25;
      display:inline-flex;gap:8px;align-items:center;
      height:40px;
      white-space:nowrap;
    }

    .kv{display:inline-flex;gap:8px;align-items:center}
    .kv label{font-size:12px;color:var(--muted)}

    #canvas{width:100%;height:100%;display:block;touch-action:none;background:#fff}
    #spark{width:140px;height:36px;border-radius:10px;border:1px solid var(--line);background:rgba(0,0,0,.03)}

    /* メニュー最少化（手動） */
    header.collapsed #menuPanel{ display:none; }
    header.collapsed #stats,
    header.collapsed #spark{ display:none; }

    /* スマホのときは少し詰める */
    @media (max-width: 520px){
      button,select,input[type="range"]{ padding:9px 10px; }
      input[type="range"]{ width:130px; }
      #spark{ width:120px; }
    }
  </style>
</head>
<body>
<div id="wrap">
  <header id="topHeader">
    <div class="row" id="topRow">
      <button id="toggleMenu">Compact</button>
      <button id="play" class="primary">Play</button>
      <button id="random">Random</button>
      <button id="clear">Clear</button>
      <span class="pill" id="stats">Gen: 0 / Alive: 0</span>
      <canvas id="spark" width="140" height="36" aria-label="alive history"></canvas>
    </div>

    <div id="menuPanel">
      <div class="row">
        <span class="kv">
          <label for="cellSize">Cell</label>
          <input id="cellSize" type="range" min="4" max="26" value="10">
        </span>

        <span class="kv">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="1" max="60" value="20">
        </span>

        <span class="kv">
          <label for="density">Rnd</label>
          <input id="density" type="range" min="1" max="50" value="18">
        </span>

        <span class="kv">
          <label for="colorMode">Color</label>
          <select id="colorMode">
            <option value="mono">B/W</option>
            <option value="age">Age</option>
            <option value="neon">Neon</option>
            <option value="rainbow">Rainbow</option>
          </select>
        </span>
        <span class="kv">
          <label for="wrapEdges">Wrap</label>
          <select id="wrapEdges">
            <option value="on">ON</option>
            <option value="off">OFF</option>
          </select>
        </span>

        <span class="kv">
          <label for="autoStop">Stop</label>
          <select id="autoStop">
            <option value="off">OFF</option>
            <option value="still">Still</option>
            <option value="blink2">Blink2</option>
          </select>
        </span>
      </div>
    </div>
  </header>

  <canvas id="canvas"></canvas>
</div>

<script>
(() => {
  const BG = "#ffffff";

  // ====== DOM ======
  const headerEl = document.getElementById("topHeader");
  const toggleMenuBtn = document.getElementById("toggleMenu");

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { alpha: false });

  const spark = document.getElementById("spark");
  const sctx = spark.getContext("2d", { alpha: false });

  const playBtn = document.getElementById("play");
  const randomBtn = document.getElementById("random");
  const clearBtn = document.getElementById("clear");

  const cellSizeEl = document.getElementById("cellSize");
  const speedEl = document.getElementById("speed");
  const densityEl = document.getElementById("density");
  const statsEl = document.getElementById("stats");
  const colorModeEl = document.getElementById("colorMode");
  const wrapEdgesEl = document.getElementById("wrapEdges");
  const autoStopEl = document.getElementById("autoStop");

  // ====== 簡易テスト（コンソールに出る） ======
  function assert(cond, msg){
    if(!cond) throw new Error("[SelfTest] " + msg);
  }
  assert(canvas && ctx, "canvas/context missing");
  assert(playBtn && randomBtn && clearBtn, "basic buttons missing");
  assert(cellSizeEl && speedEl && densityEl, "sliders missing");
  assert(statsEl && spark && sctx, "stats/spark missing");
  // ここが今回の原因になりやすい箇所
  assert(colorModeEl, "#colorMode is missing (menu HTML broken?)");

  // ====== メニュー（手動の折りたたみ） ======
  const MENU_COLLAPSE_KEY = "lifegame_menu_compact_v1";
  function setMenuCollapsed(collapsed){
    headerEl.classList.toggle("collapsed", collapsed);
    toggleMenuBtn.textContent = collapsed ? "Menu" : "Compact";
    try { localStorage.setItem(MENU_COLLAPSE_KEY, collapsed ? "1" : "0"); } catch {}
  }
  function initMenuCollapsed(){
    let v = null;
    try { v = localStorage.getItem(MENU_COLLAPSE_KEY); } catch {}
    if (v === "1") setMenuCollapsed(true);
    else if (v === "0") setMenuCollapsed(false);
    else setMenuCollapsed(window.innerWidth <= 520);
  }
  toggleMenuBtn.addEventListener("click", () => {
    setMenuCollapsed(!headerEl.classList.contains("collapsed"));
  });

  // ====== 状態 ======
  let cellSize = +cellSizeEl.value;
  let w = 0, h = 0, cols = 0, rows = 0;
  let gen = 0;
  let running = false;

  let alive = null;
  let alive2 = null;
  let age = null;
  let age2 = null;

  let heat = null;   // セルが「最近いた」履歴（残像）
  let heat2 = null;

  let dpr = 1;
  let lastT = 0;
  let acc = 0;

  let lastBirths = 0;
  let lastDeaths = 0;

  const history = [];
  const HISTORY_MAX = 200;

  // ====== 履歴グラデーション（残像） ======
  // 非B/Wのとき、「その座標にセルがいた履歴」を heat として保持して、時間で減衰させる
  const HEAT_MAX = 255;
  const HEAT_FADE_SEC = 1.2; // だいたいこの秒数で消える

  function clamp(v, lo, hi){
    return v < lo ? lo : (v > hi ? hi : v);
  }

  function getHeatDecay(){
    const hz = +(speedEl ? speedEl.value : 20) || 20;
    const d = Math.ceil(HEAT_MAX / (HEAT_FADE_SEC * hz));
    return clamp(d, 1, 40);
  }

  // ====== STOP: Blink2（周期2）検出用 ======
  let oscPrev1 = null; // t-1
  let oscPrev2 = null; // t-2

  function invalidateOsc(){
    oscPrev1 = null;
    oscPrev2 = null;
  }

  function checkBlink2(){
    if (!oscPrev1 || oscPrev1.length !== alive.length) {
      oscPrev1 = new Uint8Array(alive.length);
      oscPrev2 = new Uint8Array(alive.length);
      oscPrev1.set(alive);
      oscPrev2.set(alive);
      return false;
    }

    let same = true;
    for (let i = 0; i < alive.length; i++) {
      if (alive[i] !== oscPrev2[i]) { same = false; break; }
    }

    oscPrev2.set(oscPrev1);
    oscPrev1.set(alive);

    return same;
  }

  function idx(x, y) { return y * cols + x; }

  function setCell(i, v){
    const vv = v ? 1 : 0;
    alive[i] = vv;

    if (vv) {
      age[i] = age[i] ? age[i] : 1;
      heat[i] = HEAT_MAX;
    } else {
      // 手で消したら残像も即消す（直感優先）
      heat[i] = 0;
    }
  }

  function resize(preserve=true) {
    dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    w = Math.floor(rect.width);
    h = Math.floor(rect.height);
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const newCols = Math.max(10, Math.floor(w / cellSize));
    const newRows = Math.max(10, Math.floor(h / cellSize));

    const canPreserve = preserve && alive && (cols > 0) && (rows > 0);

    if (!canPreserve) {
      cols = newCols; rows = newRows;
      alive = new Uint8Array(cols * rows);
      alive2 = new Uint8Array(cols * rows);
      age = new Uint16Array(cols * rows);
      age2 = new Uint16Array(cols * rows);
      heat = new Uint8Array(cols * rows);
      heat2 = new Uint8Array(cols * rows);

      gen = 0;
      lastBirths = 0;
      lastDeaths = 0;
      history.length = 0;

      seedRandom((+densityEl.value) / 100);
      draw(true);
      return;
    }

    const oldAlive = alive;
    const oldAge = age;
    const oldHeat = heat;
    const oldCols = cols;
    const oldRows = rows;

    cols = newCols; rows = newRows;
    alive = new Uint8Array(cols * rows);
    alive2 = new Uint8Array(cols * rows);
    age = new Uint16Array(cols * rows);
    age2 = new Uint16Array(cols * rows);
    heat = new Uint8Array(cols * rows);
    heat2 = new Uint8Array(cols * rows);

    const copyCols = Math.min(oldCols, cols);
    const copyRows = Math.min(oldRows, rows);

    for (let y = 0; y < copyRows; y++) {
      const srcBase = y * oldCols;
      const dstBase = y * cols;
      for (let x = 0; x < copyCols; x++) {
        const s = srcBase + x;
        const d = dstBase + x;
        alive[d] = oldAlive[s];
        age[d] = oldAge[s];
        heat[d] = oldHeat[s];
      }
    }

    while (history.length > HISTORY_MAX) history.shift();
    draw(true);
  }

  function seedRandom(density = 0.18) {
    for (let i = 0; i < alive.length; i++) {
      const v = Math.random() < density ? 1 : 0;
      alive[i] = v;
      age[i] = v ? (1 + (Math.random() * 6 | 0)) : 0;
      heat[i] = v ? HEAT_MAX : 0;
    }
    gen = 0;
    lastBirths = 0;
    lastDeaths = 0;
    invalidateOsc();
    pushHistory();
  }

  function clearAll() {
    alive.fill(0);
    age.fill(0);
    heat.fill(0);
    gen = 0;
    lastBirths = 0;
    lastDeaths = 0;
    invalidateOsc();
    pushHistory();
  }

  function countNeighbors(x, y, wrap) {
    let n = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        let xx = x + dx, yy = y + dy;

        if (wrap) {
          if (xx < 0) xx += cols; else if (xx >= cols) xx -= cols;
          if (yy < 0) yy += rows; else if (yy >= rows) yy -= rows;
        } else {
          if (xx < 0 || xx >= cols || yy < 0 || yy >= rows) continue;
        }
        n += alive[idx(xx, yy)];
      }
    }
    return n;
  }

  // ルール固定（Life: B3/S23）
  function step() {
    const wrap = (wrapEdgesEl && wrapEdgesEl.value === "on");
    let aliveCount = 0;
    let births = 0, deaths = 0;

    const decay = getHeatDecay();

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const i = idx(x, y);
        const a0 = alive[i];
        const n = countNeighbors(x, y, wrap);

        const next = a0 ? ((n === 2 || n === 3) ? 1 : 0) : ((n === 3) ? 1 : 0);
        alive2[i] = next;

        if (next) {
          aliveCount++;
          age2[i] = a0 ? Math.min(65535, age[i] + 1) : 1;
          heat2[i] = HEAT_MAX;
          if (!a0) births++;
        } else {
          age2[i] = age[i];
          const hv = heat[i];
          heat2[i] = hv > decay ? (hv - decay) : 0;
          if (a0) deaths++;
        }
      }
    }

    [alive, alive2] = [alive2, alive];
    [age, age2] = [age2, age];
    [heat, heat2] = [heat2, heat];

    gen++;
    lastBirths = births;
    lastDeaths = deaths;
    pushHistory(aliveCount);

    return { aliveCount, changed: births + deaths };
  }

  function colorSpec(x, y, a, mode) {
    if (!a) return null;

    if (mode === "mono") return { type: "solid", color: "#111" };

    let hue = 0, sat = 95, light = 50;

    if (mode === "age") {
      hue = (a * 8) % 360;
      sat = 95;
      light = 30 + a * 0.65;
    } else if (mode === "neon") {
      hue = (a * 10 + x * 2 + y * 1) % 360;
      sat = 100;
      light = 52 + Math.min(12, a * 0.12);
    } else {
      hue = (x * 6 + y * 3) % 360;
      sat = 95;
      light = 34 + a * 0.75;
    }

    light = clamp(light, 10, 90);
    return { type: "hsl", hue, sat, light };
  }

  function alphaAt(i){
    if (alive[i]) return 1;
    const hv = heat[i];
    if (!hv) return 0;
    const t = hv / HEAT_MAX;
    return clamp(Math.pow(t, 1.7) * 0.92, 0, 0.92);
  }

  // ====== 描画（Blockのみ） ======
  function draw(forceFull = false) {
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, w, h);

    const mode = (colorModeEl && colorModeEl.value) ? colorModeEl.value : "mono";
    const mono = (mode === "mono");
    let aliveCount = 0;

    if (mono) {
      // B/W は残像なし
      ctx.fillStyle = "#111";
      for (let y = 0; y < rows; y++) {
        const py = y * cellSize;
        for (let x = 0; x < cols; x++) {
          const i = idx(x, y);
          if (!alive[i]) continue;
          aliveCount++;
          ctx.fillRect(x * cellSize, py, cellSize, cellSize);
        }
      }

      statsEl.textContent = `Gen: ${gen} / Alive: ${aliveCount} / +${lastBirths} -${lastDeaths}`;
      drawSparkline();
      return;
    }

    // Color（残像あり）
    const pad = Math.max(1, Math.floor(cellSize * 0.08));

    for (let y = 0; y < rows; y++) {
      const py = y * cellSize + pad;
      for (let x = 0; x < cols; x++) {
        const i = idx(x, y);
        const a = alphaAt(i);
        if (a < 0.012) continue;
        if (alive[i]) aliveCount++;

        const aVal = age[i] || 1;
        const spec = colorSpec(x, y, aVal, mode);
        if (!spec) continue;

        ctx.fillStyle = `hsla(${spec.hue}, ${spec.sat}%, ${spec.light}%, ${a})`;
        ctx.fillRect(x * cellSize + pad, py, cellSize - pad * 2, cellSize - pad * 2);
      }
    }

    statsEl.textContent = `Gen: ${gen} / Alive: ${aliveCount} / +${lastBirths} -${lastDeaths}`;
    drawSparkline();
  }

  function setRunning(on) {
    running = on;
    playBtn.textContent = running ? "Pause" : "Play";
    if (running) requestAnimationFrame(loop);
  }

  function loop(t) {
    if (!running) return;
    if (!lastT) lastT = t;
    const dt = (t - lastT) / 1000;
    lastT = t;
    acc += dt;

    const hz = +(speedEl ? speedEl.value : 20) || 20;
    const stepSec = 1 / hz;

    let n = 0;
    while (acc >= stepSec && n < 6) {
      const res = step();
      acc -= stepSec;
      n++;

      const stopMode = autoStopEl ? autoStopEl.value : "off";

      if (stopMode === "still") {
        if (res.changed === 0) {
          setRunning(false);
          acc = 0;
          break;
        }
      } else if (stopMode === "blink2") {
        const isBlink2 = checkBlink2();
        if (res.changed === 0 || isBlink2) {
          setRunning(false);
          acc = 0;
          break;
        }
      }
    }

    draw(false);
    requestAnimationFrame(loop);
  }

  function pushHistory(aliveCountMaybe) {
    const count = (typeof aliveCountMaybe === "number") ? aliveCountMaybe : countAlive();
    history.push(count);
    if (history.length > HISTORY_MAX) history.shift();
  }

  function countAlive(){
    let c = 0;
    for (let i = 0; i < alive.length; i++) c += alive[i];
    return c;
  }

  function drawSparkline() {
    const W = spark.width, H = spark.height;
    sctx.fillStyle = "#f3f3f3";
    sctx.fillRect(0,0,W,H);

    const len = history.length;
    if (len < 2) return;

    let max = 1;
    for (let i=0;i<len;i++) if (history[i] > max) max = history[i];

    sctx.strokeStyle = "rgba(0,0,0,.55)";
    sctx.lineWidth = 1;
    sctx.beginPath();
    for (let i=0;i<len;i++){
      const x = (i/(len-1))*(W-2)+1;
      const y = H-1 - (history[i]/max)*(H-2);
      if (i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
    }
    sctx.stroke();

    sctx.fillStyle = "rgba(0,0,0,.70)";
    const x = W-2;
    const y = H-1 - (history[len-1]/max)*(H-2);
    sctx.fillRect(x-2, y-2, 4, 4);
  }

  // ====== 編集（タップ/ドラッグで同じ状態を塗る） ======
  let drawing = false;
  let drawValue = 1;

  function posToCell(clientX, clientY) {
    const r = canvas.getBoundingClientRect();
    const x = Math.floor((clientX - r.left) / cellSize);
    const y = Math.floor((clientY - r.top) / cellSize);
    return { x, y };
  }

  function paintAt(x, y) {
    if (x < 0 || y < 0 || x >= cols || y >= rows) return;
    const i = idx(x, y);
    setCell(i, drawValue);
  }

  canvas.addEventListener("pointerdown", (e) => {
    if (e.pointerType === "touch" && e.isPrimary === false) return;
    drawing = true;
    canvas.setPointerCapture(e.pointerId);
    const { x, y } = posToCell(e.clientX, e.clientY);
    if (x < 0 || y < 0 || x >= cols || y >= rows) return;
    const i = idx(x, y);
    drawValue = alive[i] ? 0 : 1;
    paintAt(x, y);
    draw(true);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!drawing) return;
    const { x, y } = posToCell(e.clientX, e.clientY);
    paintAt(x, y);
    draw(true);
  });

  canvas.addEventListener("pointerup", () => { drawing = false; invalidateOsc(); });
  canvas.addEventListener("pointercancel", () => { drawing = false; invalidateOsc(); });

  // ====== UI ======
  playBtn.addEventListener("click", () => setRunning(!running));
  randomBtn.addEventListener("click", () => { seedRandom((+densityEl.value)/100); draw(true); });
  clearBtn.addEventListener("click", () => { clearAll(); draw(true); });

  cellSizeEl.addEventListener("input", () => {
    cellSize = +cellSizeEl.value;
    resize(true);
    invalidateOsc();
  });

  speedEl.addEventListener("input", () => { acc = 0; });

  // ここは null になりうるので必ずガード
  if (colorModeEl) colorModeEl.addEventListener("change", () => draw(true));
  if (wrapEdgesEl) wrapEdgesEl.addEventListener("change", () => draw(true));

  window.addEventListener("keydown", (e) => {
    if (e.key === " "){
      e.preventDefault();
      setRunning(!running);
    }
  });

  window.addEventListener("resize", () => { resize(true); invalidateOsc(); });

  // 初期化
  initMenuCollapsed();
  resize(false);
  console.log("[SelfTest] OK: UI elements found, app initialized.");
})();
</script>

<script>
// Service Worker registration (PWA)
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("./sw.js").catch((err) => {
      console.warn("SW register failed:", err);
    });
  });
}
</script>
</body>
</html>
